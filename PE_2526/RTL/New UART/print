module uart_print #(
    parameter CLK_FREQ = 50000000,   // 50 MHz
    parameter BAUD_RATE = 9600,
    parameter MSG_LEN = 13           // Length of message
)(
    input wire clk,
    input wire reset,
    input wire start_print,
    output wire tx,
    output reg busy
);

// UART TX signals
reg [7:0] tx_data;
reg tx_start;
wire tx_busy;

uart_tx #(
    .CLK_FREQ(CLK_FREQ),
    .BAUD_RATE(BAUD_RATE)
) uart_tx_inst (
    .clk(clk),
    .reset(reset),
    .tx_start(tx_start),
    .tx_data(tx_data),
    .tx(tx),
    .busy(tx_busy)
);

// Message ROM
reg [7:0] message [0:MSG_LEN-1];
initial begin
    message[0]  = "H";
    message[1]  = "e";
    message[2]  = "l";
    message[3]  = "l";
    message[4]  = "o";
    message[5]  = ",";
    message[6]  = " ";
    message[7]  = "Y";
    message[8]  = "i";
    message[9]  = "g";
    message[10] = "a";
    message[11] = "l";
    message[12] = "\n";
end

// FSM
reg [3:0] state = 0;
reg [$clog2(MSG_LEN):0] index = 0;

always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= 0;
        index <= 0;
        tx_start <= 0;
        busy <= 0;
    end else begin
        case (state)
            0: begin
                if (start_print) begin
                    busy <= 1;
                    index <= 0;
                    state <= 1;
                end
            end
            1: begin
                if (!tx_busy) begin
                    tx_data <= message[index];
                    tx_start <= 1;
                    state <= 2;
                end
            end
            2: begin
                tx_start <= 0;
                state <= 3;
            end
            3: begin
                if (tx_busy == 0) begin
                    index <= index + 1;
                    if (index == MSG_LEN - 1) begin
                        state <= 4;
                    end else begin
                        state <= 1;
                    end
                end
            end
            4: begin
                busy <= 0;
                state <= 0;
            end
        endcase
    end
end

endmodule